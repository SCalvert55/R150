import tkinter as tk
from tkinter import ttk, messagebox
import json
import os
import serial
import serial.tools.list_ports
import threading
import time

RECIPES_FILE = "ald_recipes.json"

class ArduinoManager:
    def __init__(self):
        self.serial_conn = None
        self.connected = False
        self.reading_thread = None
        self.running = False
        self.temp_data = {"Reactor": "--", "Precursor_A": "--", "Precursor_B": "--", "Heater": "--"}
        self.callbacks = []
        
    def connect(self, port, baudrate=9600):
        try:
            self.serial_conn = serial.Serial(port, baudrate, timeout=1)
            time.sleep(2)
            self.connected = True
            self.running = True
            self.reading_thread = threading.Thread(target=self._read_loop, daemon=True)
            self.reading_thread.start()
            return True
        except Exception as e:
            print(f"Connection error: {e}")
            return False
    
    def disconnect(self):
        self.running = False
        self.connected = False
        if self.serial_conn:
            self.serial_conn.close()
            self.serial_conn = None
    
    def send_command(self, command):
        if self.connected and self.serial_conn:
            try:
                self.serial_conn.write(f"{command}\n".encode())
                return True
            except Exception as e:
                print(f"Send error: {e}")
                return False
        return False
    
    def emergency_stop(self):
        self.send_command("EMERGENCY_STOP")
    
    def get_temp(self, sensor_name):
        """Get temperature for a specific sensor"""
        temp_str = self.temp_data.get(sensor_name, "--")
        if temp_str == "--":
            return None
        try:
            return float(temp_str)
        except:
            return None
    
    def _read_loop(self):
        while self.running:
            if self.serial_conn and self.serial_conn.in_waiting:
                try:
                    line = self.serial_conn.readline().decode().strip()
                    self._parse_data(line)
                except Exception as e:
                    print(f"Read error: {e}")
            time.sleep(0.1)
    
    def _parse_data(self, line):
        try:
            if line.startswith("TEMP:"):
                parts = line.split(":")
                if len(parts) == 3:
                    sensor = parts[1]
                    temp = parts[2]
                    self.temp_data[sensor] = temp
                    for callback in self.callbacks:
                        callback(self.temp_data)
        except Exception as e:
            print(f"Parse error: {e}")
    
    def register_callback(self, callback):
        self.callbacks.append(callback)

class ThermocoupleFrame(tk.LabelFrame):
    def __init__(self, parent, arduino_mgr):
        super().__init__(parent, text="Temperature Monitoring", padx=15, pady=15, 
                        font=("Arial", 11, "bold"), bg="#f0f0f0")
        
        self.arduino_mgr = arduino_mgr
        self.labels = {}
        
        for name in ["Reactor", "Precursor_A", "Precursor_B", "Heater"]:
            frame = tk.Frame(self, bg="#f0f0f0")
            frame.pack(fill="x", pady=5)
            
            display_name = name.replace("_", " ")
            tk.Label(frame, text=f"{display_name}:", font=("Arial", 12), 
                    bg="#f0f0f0", width=12, anchor="w").pack(side="left")
            
            lbl = tk.Label(frame, text="-- Â°C", font=("Arial", 12, "bold"), 
                          bg="white", width=15, relief="sunken", anchor="e", padx=5)
            lbl.pack(side="left", padx=5)
            self.labels[name] = lbl
        
        self.arduino_mgr.register_callback(self.update_temps)
    
    def update_temps(self, temp_data):
        for name, temp in temp_data.items():
            if name in self.labels:
                self.labels[name].config(text=f"{temp} Â°C")

class ArduinoWindow(tk.Toplevel):
    def __init__(self, parent, arduino_mgr):
        super().__init__(parent)
        self.title("Arduino Connection")
        self.geometry("450x250")
        self.configure(bg="#f0f0f0")
        
        self.arduino_mgr = arduino_mgr
        
        port_frame = tk.Frame(self, bg="#f0f0f0")
        port_frame.pack(pady=20, padx=20, fill="x")
        
        tk.Label(port_frame, text="COM Port:", font=("Arial", 11), 
                bg="#f0f0f0").pack(side="left", padx=5)
        
        self.port_var = tk.StringVar()
        self.port_entry = ttk.Combobox(port_frame, textvariable=self.port_var, 
                                       width=15, font=("Arial", 10))
        self.port_entry.pack(side="left", padx=5)
        
        tk.Button(port_frame, text="Refresh Ports", command=self.refresh_ports,
                 font=("Arial", 10), bg="#4CAF50", fg="white", 
                 activebackground="#45a049").pack(side="left", padx=5)
        
        status_frame = tk.Frame(self, bg="#f0f0f0")
        status_frame.pack(pady=10)
        
        tk.Label(status_frame, text="Status:", font=("Arial", 11), 
                bg="#f0f0f0").pack(side="left", padx=5)
        
        self.status_label = tk.Label(status_frame, text="Disconnected", 
                                     font=("Arial", 11, "bold"), fg="red", 
                                     bg="white", width=15, relief="sunken")
        self.status_label.pack(side="left", padx=5)
        
        btn_frame = tk.Frame(self, bg="#f0f0f0")
        btn_frame.pack(pady=20)
        
        self.connect_btn = tk.Button(btn_frame, text="Connect", 
                                     command=self.toggle_connection,
                                     font=("Arial", 11, "bold"), bg="#2196F3", 
                                     fg="white", width=12, height=2,
                                     activebackground="#0b7dda")
        self.connect_btn.pack(side="left", padx=10)
        
        tk.Button(btn_frame, text="Test Connection", command=self.test_connection,
                 font=("Arial", 11), bg="#FF9800", fg="white", width=12, height=2,
                 activebackground="#e68900").pack(side="left", padx=10)
        
        self.refresh_ports()
        
    def refresh_ports(self):
        ports = [port.device for port in serial.tools.list_ports.comports()]
        self.port_entry['values'] = ports
        if ports:
            self.port_entry.current(0)
    
    def toggle_connection(self):
        if self.arduino_mgr.connected:
            self.arduino_mgr.disconnect()
            self.status_label.config(text="Disconnected", fg="red")
            self.connect_btn.config(text="Connect")
        else:
            port = self.port_var.get()
            if not port:
                messagebox.showerror("Error", "Please select a COM port")
                return
            
            if self.arduino_mgr.connect(port):
                self.status_label.config(text="Connected", fg="green")
                self.connect_btn.config(text="Disconnect")
            else:
                messagebox.showerror("Error", "Failed to connect to Arduino")
    
    def test_connection(self):
        if self.arduino_mgr.connected:
            self.arduino_mgr.send_command("TEST")
            messagebox.showinfo("Test", "Test command sent to Arduino")
        else:
            messagebox.showwarning("Warning", "Not connected to Arduino")

class RecipeWindow(tk.Toplevel):
    def __init__(self, parent):
        super().__init__(parent)
        self.title("ALD Recipe Manager")
        self.geometry("600x800")
        self.configure(bg="#f0f0f0")
        
        self.recipes = self.load_recipes()
        
        select_frame = tk.Frame(self, bg="#f0f0f0")
        select_frame.pack(pady=15, padx=20, fill="x")
        
        tk.Label(select_frame, text="Select Recipe:", font=("Arial", 11, "bold"),
                bg="#f0f0f0").pack(side="left", padx=5)
        
        self.selected = tk.StringVar(value="New Recipe")
        recipe_menu = ttk.Combobox(select_frame, textvariable=self.selected,
                                   values=["New Recipe"] + list(self.recipes.keys()),
                                   font=("Arial", 10), width=25)
        recipe_menu.pack(side="left", padx=5)
        recipe_menu.bind("<<ComboboxSelected>>", lambda e: self.load_recipe(self.selected.get()))
        
        fields_frame = tk.LabelFrame(self, text="Recipe Parameters", 
                                    font=("Arial", 11, "bold"), bg="#f0f0f0",
                                    padx=15, pady=15)
        fields_frame.pack(pady=10, padx=20, fill="both", expand=True)
        
        self.entries = {}
        
        fields = [
            ("Recipe Name", "name"),
            ("Number of Cycles", "cycles"),
            ("Precursor A", "precursor_a"),
            ("Pulse A Time (s)", "pulse_a"),
            ("Purge A Time (s)", "purge_a"),
            ("Precursor B", "precursor_b"),
            ("Pulse B Time (s)", "pulse_b"),
            ("Purge B Time (s)", "purge_b"),
            ("Reactor Temperature (Â°C)", "temp_reactor"),
            ("Precursor A Temperature (Â°C)", "temp_precursor_a"),
            ("Precursor B Temperature (Â°C)", "temp_precursor_b"),
            ("Temperature Tolerance (Â°C)", "temp_tolerance"),
        ]
        
        for i, (label, key) in enumerate(fields):
            row_frame = tk.Frame(fields_frame, bg="#f0f0f0")
            row_frame.pack(fill="x", pady=5)
            
            tk.Label(row_frame, text=label, font=("Arial", 10),
                    bg="#f0f0f0", width=30, anchor="w").pack(side="left")
            
            ent = tk.Entry(row_frame, font=("Arial", 10), width=20)
            ent.pack(side="left", padx=5)
            self.entries[key] = ent
        
        btn_frame = tk.Frame(self, bg="#f0f0f0")
        btn_frame.pack(pady=15)
        
        tk.Button(btn_frame, text="Save Recipe", command=self.save_recipe,
                 font=("Arial", 11, "bold"), bg="#4CAF50", fg="white",
                 width=12, height=2).pack(side="left", padx=10)
        
        tk.Button(btn_frame, text="Delete Recipe", command=self.delete_recipe,
                 font=("Arial", 11, "bold"), bg="#f44336", fg="white",
                 width=12, height=2).pack(side="left", padx=10)
    
    def load_recipes(self):
        if os.path.exists(RECIPES_FILE):
            with open(RECIPES_FILE, "r") as f:
                return json.load(f)
        return {}
    
    def load_recipe(self, name):
        if name == "New Recipe" or name not in self.recipes:
            for entry in self.entries.values():
                entry.delete(0, tk.END)
            return
        
        data = self.recipes[name]
        
        for key, entry in self.entries.items():
            entry.delete(0, tk.END)
            if key in data:
                entry.insert(0, data[key])
    
    def save_recipe(self):
        name = self.entries["name"].get().strip()
        if not name:
            messagebox.showerror("Error", "Please enter a recipe name")
            return
        
        self.recipes[name] = {
            key: entry.get() for key, entry in self.entries.items() if key != "name"
        }
        
        with open(RECIPES_FILE, "w") as f:
            json.dump(self.recipes, f, indent=4)
        
        messagebox.showinfo("Success", f"Recipe '{name}' saved successfully")
        self.selected.set(name)

        
    
    def delete_recipe(self):
        name = self.selected.get()
        if name in self.recipes:
            if messagebox.askyesno("Confirm", f"Delete recipe '{name}'?"):
                del self.recipes[name]
                with open(RECIPES_FILE, "w") as f:
                    json.dump(self.recipes, f, indent=4)
                messagebox.showinfo("Success", f"Recipe '{name}' deleted")
                self.selected.set("New Recipe")

class ValvesWindow(tk.Toplevel):
    def __init__(self, parent, arduino_mgr):
        super().__init__(parent)
        self.title("Valve Control")
        self.geometry("500x400")
        self.configure(bg="#f0f0f0")
        self.arduino_mgr = arduino_mgr
        
        tk.Label(self, text="Valve Control Panel", font=("Arial", 14, "bold"),
                bg="#f0f0f0").pack(pady=15)
        
        valves = ["Precursor A", "Precursor B", "Purge Gas", "Vacuum", "Vent"]
        
        for valve in valves:
            frame = tk.Frame(self, bg="#f0f0f0")
            frame.pack(pady=10, padx=20, fill="x")
            
            tk.Label(frame, text=valve, font=("Arial", 11),
                    bg="#f0f0f0", width=15, anchor="w").pack(side="left")
            
            tk.Button(frame, text="Open", command=lambda v=valve: self.control_valve(v, "OPEN"),
                     font=("Arial", 10), bg="#4CAF50", fg="white", width=8).pack(side="left", padx=5)
            
            tk.Button(frame, text="Close", command=lambda v=valve: self.control_valve(v, "CLOSE"),
                     font=("Arial", 10), bg="#f44336", fg="white", width=8).pack(side="left", padx=5)
    
    def control_valve(self, valve, action):
        cmd = f"VALVE:{valve.replace(' ', '_')}:{action}"
        self.arduino_mgr.send_command(cmd)

class HeaterWindow(tk.Toplevel):
    def __init__(self, parent, arduino_mgr):
        super().__init__(parent)
        self.title("Heater Control")
        self.geometry("500x400")
        self.configure(bg="#f0f0f0")
        self.arduino_mgr = arduino_mgr
        
        tk.Label(self, text="Heater Control Panel", font=("Arial", 14, "bold"),
                bg="#f0f0f0").pack(pady=15)
        
        # Reactor heater
        reactor_frame = tk.LabelFrame(self, text="Reactor Heater", 
                                      font=("Arial", 11, "bold"), bg="#f0f0f0",
                                      padx=15, pady=15)
        reactor_frame.pack(pady=10, padx=20, fill="x")
        
        frame = tk.Frame(reactor_frame, bg="#f0f0f0")
        frame.pack(pady=5)
        
        tk.Label(frame, text="Set Temperature (Â°C):", font=("Arial", 11),
                bg="#f0f0f0").pack(side="left", padx=5)
        
        self.temp_reactor_var = tk.StringVar()
        temp_entry = tk.Entry(frame, textvariable=self.temp_reactor_var, font=("Arial", 10), width=10)
        temp_entry.pack(side="left", padx=5)
        
        tk.Button(frame, text="Set", command=lambda: self.set_temperature("REACTOR", self.temp_reactor_var.get()),
                 font=("Arial", 11), bg="#2196F3", fg="white",
                 width=10).pack(side="left", padx=10)
        
        # Precursor A heater
        precA_frame = tk.LabelFrame(self, text="Precursor A Heater", 
                                    font=("Arial", 11, "bold"), bg="#f0f0f0",
                                    padx=15, pady=15)
        precA_frame.pack(pady=10, padx=20, fill="x")
        
        frame = tk.Frame(precA_frame, bg="#f0f0f0")
        frame.pack(pady=5)
        
        tk.Label(frame, text="Set Temperature (Â°C):", font=("Arial", 11),
                bg="#f0f0f0").pack(side="left", padx=5)
        
        self.temp_precA_var = tk.StringVar()
        temp_entry = tk.Entry(frame, textvariable=self.temp_precA_var, font=("Arial", 10), width=10)
        temp_entry.pack(side="left", padx=5)
        
        tk.Button(frame, text="Set", command=lambda: self.set_temperature("PRECURSOR_A", self.temp_precA_var.get()),
                 font=("Arial", 11), bg="#2196F3", fg="white",
                 width=10).pack(side="left", padx=10)
        
        # Precursor B heater
        precB_frame = tk.LabelFrame(self, text="Precursor B Heater", 
                                    font=("Arial", 11, "bold"), bg="#f0f0f0",
                                    padx=15, pady=15)
        precB_frame.pack(pady=10, padx=20, fill="x")
        
        frame = tk.Frame(precB_frame, bg="#f0f0f0")
        frame.pack(pady=5)
        
        tk.Label(frame, text="Set Temperature (Â°C):", font=("Arial", 11),
                bg="#f0f0f0").pack(side="left", padx=5)
        
        self.temp_precB_var = tk.StringVar()
        temp_entry = tk.Entry(frame, textvariable=self.temp_precB_var, font=("Arial", 10), width=10)
        temp_entry.pack(side="left", padx=5)
        
        tk.Button(frame, text="Set", command=lambda: self.set_temperature("PRECURSOR_B", self.temp_precB_var.get()),
                 font=("Arial", 11), bg="#2196F3", fg="white",
                 width=10).pack(side="left", padx=10)
    
    def set_temperature(self, heater_type, temp_str):
        temp = temp_str.strip()
        if not temp.replace('.', '').isdigit():
            messagebox.showerror("Error", "Please enter a valid temperature")
            return
        
        cmd = f"TEMP_SETPOINT:{heater_type}:{temp}"
        self.arduino_mgr.send_command(cmd)
        messagebox.showinfo("Success", f"{heater_type} setpoint set to {temp} Â°C")

class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("ALD R150 Control System")
        self.geometry("900x750")
        self.configure(bg="#e0e0e0")
        
        self.arduino_mgr = ArduinoManager()
        self.process_running = False
        
        self.create_toolbar()
        self.create_header()
        self.create_emergency_stops()
        self.create_main_content()
        
        self.protocol("WM_DELETE_WINDOW", self.on_closing)
    
    def create_toolbar(self):
        toolbar = tk.Frame(self, bg="#263238", height=50)
        toolbar.pack(fill="x", side="top")
        
        btn_style = {
            "font": ("Arial", 11, "bold"),
            "bg": "#37474F",
            "fg": "white",
            "activebackground": "#546E7A",
            "activeforeground": "white",
            "bd": 0,
            "padx": 15,
            "pady": 8,
            "cursor": "hand2"
        }
        
        tk.Button(toolbar, text="âš™ Valves", command=self.open_valves,
                 **btn_style).pack(side="left", padx=5, pady=8)
        
        tk.Button(toolbar, text="ðŸ“‹ Recipes", command=self.open_recipes,
                 **btn_style).pack(side="left", padx=5, pady=8)
        
        tk.Button(toolbar, text="ðŸ”Œ Arduino", command=self.open_arduino,
                 **btn_style).pack(side="left", padx=5, pady=8)
        tk.Button(toolbar, text="ðŸ”¥ Heater", command=self.open_heater,
                    **btn_style).pack(side="left", padx=5, pady=8)
        
        self.conn_indicator = tk.Label(toolbar, text="â— Disconnected", 
                                       font=("Arial", 10), bg="#263238", 
                                       fg="#f44336", padx=10)
        self.conn_indicator.pack(side="left", padx=20)
        
        self.start_btn = tk.Button(toolbar, text="â–¶ START", 
                                   command=self.start_process,
                                   font=("Arial", 11, "bold"), bg="#4CAF50",
                                   fg="white", padx=20, pady=8, bd=0,
                                   cursor="hand2", activebackground="#45a049")
        self.start_btn.pack(side="right", padx=10, pady=8)
        
        tk.Button(toolbar, text="â–  STOP", command=self.stop_process,
                 font=("Arial", 11, "bold"), bg="#f44336", fg="white",
                 padx=20, pady=8, bd=0, cursor="hand2",
                 activebackground="#da190b").pack(side="right", padx=5, pady=8)
        
        self.update_connection_status()
    
    def create_header(self):
        header = tk.Frame(self, bg="#e0e0e0")
        header.pack(pady=15)
        
        tk.Label(header, text="ALD R150 Control System",
                font=("Arial", 20, "bold"), bg="#e0e0e0",
                fg="#263238").pack()
    
    def create_emergency_stops(self):
        estop_frame = tk.Frame(self, bg="#e0e0e0")
        estop_frame.pack(pady=10)
        
        tk.Button(estop_frame, text="âš  EMERGENCY STOP âš ",
                 command=self.emergency_stop,
                 font=("Arial", 16, "bold"), bg="#d32f2f", fg="white",
                 width=25, height=2, relief="raised", bd=3,
                 cursor="hand2", activebackground="#b71c1c").pack(pady=5)
    
    def create_main_content(self):
        content = tk.Frame(self, bg="#e0e0e0")
        content.pack(fill="both", expand=True, padx=20, pady=10)
        
        # Recipe selector
        recipe_frame = tk.LabelFrame(content, text="Active Recipe",
                                    font=("Arial", 11, "bold"), bg="#f0f0f0",
                                    padx=15, pady=10)
        recipe_frame.pack(fill="x", pady=5)
        
        select_row = tk.Frame(recipe_frame, bg="#f0f0f0")
        select_row.pack(fill="x")
        
        tk.Label(select_row, text="Recipe:", font=("Arial", 10),
                bg="#f0f0f0").pack(side="left", padx=5)
        
        self.active_recipe_var = tk.StringVar(value="None")
        self.active_recipe_menu = ttk.Combobox(select_row, textvariable=self.active_recipe_var,
                                              font=("Arial", 10), width=30, state="readonly")
        self.active_recipe_menu.pack(side="left", padx=5)
        
        tk.Button(select_row, text="Refresh", command=self.refresh_recipe_list,
                 font=("Arial", 9), bg="#2196F3", fg="white",
                 width=10).pack(side="left", padx=5)
        
        self.refresh_recipe_list()
        
        # Temperature
        self.thermo = ThermocoupleFrame(content, self.arduino_mgr)
        self.thermo.pack(fill="x", pady=10)
        
        # Status
        status_frame = tk.LabelFrame(content, text="System Status",
                                     font=("Arial", 11, "bold"), bg="#f0f0f0",
                                     padx=15, pady=15)
        status_frame.pack(fill="both", expand=True, pady=10)
        
        self.status_text = tk.Text(status_frame, height=8, font=("Courier", 10),
                                   bg="black", fg="#00ff00", state="disabled")
        self.status_text.pack(fill="both", expand=True)
        
        self.log_message("System initialized. Ready for operation.")
    
    def refresh_recipe_list(self):
        if os.path.exists(RECIPES_FILE):
            with open(RECIPES_FILE, "r") as f:
                recipes = json.load(f)
            recipe_names = list(recipes.keys())
            self.active_recipe_menu['values'] = recipe_names if recipe_names else ["None"]
            if recipe_names:
                self.active_recipe_var.set(recipe_names[0])
            else:
                self.active_recipe_var.set("None")
        else:
            self.active_recipe_menu['values'] = ["None"]
            self.active_recipe_var.set("None")
    
    def update_connection_status(self):
        if self.arduino_mgr.connected:
            self.conn_indicator.config(text="â— Connected", fg="#4CAF50")
        else:
            self.conn_indicator.config(text="â— Disconnected", fg="#f44336")
        self.after(500, self.update_connection_status)
    
    def log_message(self, message):
        self.status_text.config(state="normal")
        timestamp = time.strftime("%H:%M:%S")
        self.status_text.insert("end", f"[{timestamp}] {message}\n")
        self.status_text.see("end")
        self.status_text.config(state="disabled")
    
    def emergency_stop(self):
        self.log_message("âš  EMERGENCY STOP ACTIVATED âš ")
        self.arduino_mgr.emergency_stop()
        self.process_running = False
        self.start_btn.config(state="normal")
        messagebox.showwarning("Emergency Stop", 
                              "Emergency stop executed!\nAll processes halted.")
    
    def open_valves(self):
        ValvesWindow(self, self.arduino_mgr)
    
    def open_recipes(self):
        RecipeWindow(self)
    
    def open_arduino(self):
        ArduinoWindow(self, self.arduino_mgr)

    def open_heater(self):
        HeaterWindow(self, self.arduino_mgr)
    
    def get_selected_recipe(self):
        recipe_name = self.active_recipe_var.get()
        
        if recipe_name == "None":
            raise Exception("No recipe selected")
        
        if not os.path.exists(RECIPES_FILE):
            raise Exception("No recipes file found")
        
        with open(RECIPES_FILE, "r") as f:
            recipes = json.load(f)
        
        if recipe_name not in recipes:
            raise Exception(f"Recipe '{recipe_name}' not found")
        
        recipe_data = recipes[recipe_name]
        recipe_data["name"] = recipe_name
        
        # Validate required fields
        required = ["temp_reactor", "temp_precursor_a", "temp_precursor_b"]
        for field in required:
            if field not in recipe_data or not recipe_data[field]:
                raise Exception(f"Recipe missing {field.replace('_', ' ')}")
        
        return recipe_data
    
    def wait_for_temperatures(self, recipe):
        """Wait for all temperatures to reach their setpoints"""
        self.log_message("Waiting for temperatures to stabilize...")
        
        target_reactor = float(recipe["temp_reactor"])
        target_precA = float(recipe["temp_precursor_a"])
        target_precB = float(recipe["temp_precursor_b"])
        tolerance = float(recipe.get("temp_tolerance", 2.0))
        
        max_wait_time = 1800  # 30 minutes max
        start_time = time.time()
        check_interval = 2  # Check every 2 seconds
        
        while self.process_running:
            if time.time() - start_time > max_wait_time:
                raise Exception("Temperature stabilization timeout (30 min)")
            
            # Get current temperatures
            temp_reactor = self.arduino_mgr.get_temp("Reactor")
            temp_precA = self.arduino_mgr.get_temp("Precursor_A")
            temp_precB = self.arduino_mgr.get_temp("Precursor_B")
            
            # Check if any reading is invalid
            if temp_reactor is None or temp_precA is None or temp_precB is None:
                self.log_message("Waiting for valid temperature readings...")
                time.sleep(check_interval)
                continue
            
            # Check if all temperatures are within tolerance
            reactor_ok = abs(temp_reactor - target_reactor) <= tolerance
            precA_ok = abs(temp_precA - target_precA) <= tolerance
            precB_ok = abs(temp_precB - target_precB) <= tolerance
            
            # Log current status
            self.log_message(f"Reactor: {temp_reactor:.1f}Â°C (target: {target_reactor}Â°C) {'âœ“' if reactor_ok else 'âœ—'}")
            self.log_message(f"Precursor A: {temp_precA:.1f}Â°C (target: {target_precA}Â°C) {'âœ“' if precA_ok else 'âœ—'}")
            self.log_message(f"Precursor B: {temp_precB:.1f}Â°C (target: {target_precB}Â°C) {'âœ“' if precB_ok else 'âœ—'}")
            
            if reactor_ok and precA_ok and precB_ok:
                self.log_message("All temperatures at setpoint! Starting recipe...")
                return True
            
            time.sleep(check_interval)
        
        return False
    
    def run_recipe(self, recipe):
        try:
            self.log_message(f"Recipe: {recipe['name']}")
            self.log_message(f"Reactor Temp: {recipe['temp_reactor']}Â°C")
            self.log_message(f"Precursor A Temp: {recipe['temp_precursor_a']}Â°C")
            self.log_message(f"Precursor B Temp: {recipe['temp_precursor_b']}Â°C")
            self.log_message("=" * 50)
            
            # Set all temperature setpoints
            self.arduino_mgr.send_command(f"TEMP_SETPOINT:REACTOR:{recipe['temp_reactor']}")
            self.arduino_mgr.send_command(f"TEMP_SETPOINT:PRECURSOR_A:{recipe['temp_precursor_a']}")
            self.arduino_mgr.send_command(f"TEMP_SETPOINT:PRECURSOR_B:{recipe['temp_precursor_b']}")
            
            # Enable PID controllers
            self.arduino_mgr.send_command("PID_ON:REACTOR")
            self.arduino_mgr.send_command("PID_ON:PRECURSOR_A")
            self.arduino_mgr.send_command("PID_ON:PRECURSOR_B")
            
            # Wait for temperatures to stabilize
            if not self.wait_for_temperatures(recipe):
                self.log_message("Process cancelled during temperature stabilization")
                return
            
            cycles = int(recipe.get("cycles", 1))
            pulse_a = float(recipe.get("pulse_a", 0.5))
            purge_a = float(recipe.get("purge_a", 5))
            pulse_b = float(recipe.get("pulse_b", 0.5))
            purge_b = float(recipe.get("purge_b", 5))
            
            self.log_message(f"Total cycles: {cycles}")
            
            for cycle in range(1, cycles + 1):
                if not self.process_running:
                    self.log_message("Process stopped by user")
                    break
                
                self.log_message(f"Cycle {cycle}/{cycles}")
                
                # Pulse A
                self.log_message(f"  Pulsing A ({pulse_a}s)")
                self.arduino_mgr.send_command("VALVE:Precursor_A:OPEN")
                time.sleep(pulse_a)
                self.arduino_mgr.send_command("VALVE:Precursor_A:CLOSE")
                
                if not self.process_running:
                    break
                
                # Purge A
                self.log_message(f"  Purging ({purge_a}s)")
                self.arduino_mgr.send_command("VALVE:Purge_Gas:OPEN")
                time.sleep(purge_a)
                self.arduino_mgr.send_command("VALVE:Purge_Gas:CLOSE")
                
                if not self.process_running:
                    break
                
                # Pulse B
                self.log_message(f"  Pulsing B ({pulse_b}s)")
                self.arduino_mgr.send_command("VALVE:Precursor_B:OPEN")
                time.sleep(pulse_b)
                self.arduino_mgr.send_command("VALVE:Precursor_B:CLOSE")
                
                if not self.process_running:
                    break
                
                # Purge B
                self.log_message(f"  Purging ({purge_b}s)")
                self.arduino_mgr.send_command("VALVE:Purge_Gas:OPEN")
                time.sleep(purge_b)
                self.arduino_mgr.send_command("VALVE:Purge_Gas:CLOSE")
            
            if self.process_running:
                self.log_message("Recipe completed successfully!")
        
        except Exception as e:
            self.log_message(f"ERROR: {str(e)}")
        finally:
            self.process_running = False
            self.start_btn.config(state="normal")
            self.arduino_mgr.send_command("PID_OFF:REACTOR")
            self.arduino_mgr.send_command("PID_OFF:PRECURSOR_A")
            self.arduino_mgr.send_command("PID_OFF:PRECURSOR_B")
            self.arduino_mgr.send_command("STOP_PROCESS")
    
    def start_process(self):
        if not self.arduino_mgr.connected:
            messagebox.showerror("Error", "Arduino not connected!")
            return
        
        try:
            recipe = self.get_selected_recipe()
        except Exception as e:
            messagebox.showerror("Error", str(e))
            return
        
        if messagebox.askyesno("Confirm", f"Start recipe '{recipe['name']}'?"):
            self.process_running = True
            self.start_btn.config(state="disabled")
            
            self.log_message(f"Starting recipe: {recipe['name']}")
            
            self.arduino_mgr.send_command("START_PROCESS")
            
            threading.Thread(target=self.run_recipe, args=(recipe,), daemon=True).start()
    
    def stop_process(self):
        if self.process_running:
            if messagebox.askyesno("Confirm", "Stop ALD process?"):
                self.process_running = False
                self.start_btn.config(state="normal")
                self.log_message("ALD process stopped")
                self.arduino_mgr.send_command("STOP_PROCESS")
                self.arduino_mgr.send_command("PID_OFF:REACTOR")
                self.arduino_mgr.send_command("PID_OFF:PRECURSOR_A")
                self.arduino_mgr.send_command("PID_OFF:PRECURSOR_B")
    
    def on_closing(self):
        if self.process_running:
            if not messagebox.askyesno("Warning", 
                "Process is running! Are you sure you want to exit?"):
                return
        
        self.arduino_mgr.disconnect()
        self.destroy()

if __name__ == "__main__":
    app = App()
    app.mainloop()